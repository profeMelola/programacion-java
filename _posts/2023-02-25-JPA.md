---
typora-copy-images-to: ../assets/img/poo-tablas/
typora-root-url: ../../
layout: post
title: JPA con Spring Boot
categories: bd
conToc: true
permalink: jpa-con-spring-boot
---

En este apartado vamos a ver el funcionamiento de la parte ORM del framework llamado [Spring Boot](https://spring.io/)

## Esqueleto

El primer paso es descargar el esqueleto de proyecto desde [aquí](/programacion-java/assets/jpa.zip). En el archivo `pom.xml` están definidas las siguientes dependencias

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

* `spring-boot-starter-data-jpa` define que vamos a trabajar con el ORM Hibernate que es una implementación de JPA (Java Persistent API)
* `com.h2database` define la base de datos en memoria `H2`
* `spring-boot-starter-test` Es el propio framework para hacer pruebas

La clase java que tiene el método `main` es JpaApplication.java

![image-20230419094909718](/programacion-java/assets/img/poo-tablas/image-20230419094909718.png)

Que simplemente hace una llamada 

```java
SpringApplication.run(JpaApplication.class, args);
```

## Entidad

Al igual que hemos hecho en [/programacion-java/repository-pattern](Repository Pattern) hemos de definir las entidades como clases POJO

```java
package org.ieselcaminas.jpa;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Customer {

  @Id
  @GeneratedValue(strategy=GenerationType.AUTO)
  private Long id;
  private String firstName;
  private String lastName;

  protected Customer() {}
  public Customer(String firstName, String lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  public Long getId() {
    return id;
  }
  public String getFirstName() {
    return firstName;
  }
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }

  @Override
  public String toString() {
    return String.format(
            "Customer[id=%d, firstName='%s', lastName='%s']",
            id, firstName, lastName);
  }

}
```

Vemos que esta clase se anota con `@Entity` para indicarle al framework que esta clase la debe tratar como una entidad que tiene persistencia en base de datos. 

```java
  @Id
  @GeneratedValue(strategy=GenerationType.AUTO)
  private Long id;
```

Estas anotaciones le indican a JPA que el atributo `id` es la clave primaria y que el valor se genera automáticamente.

## Repositorio

El siguiente paso es crear `CustomerRepository`

```java
package org.ieselcaminas.jpa;

import java.util.List;
import org.springframework.data.repository.CrudRepository;

public interface CustomerRepository extends CrudRepository<Customer, Long> {

    List<Customer> findByLastName(String lastName);

    Customer findById(long id);
}
```

Importa `CrudRepository` para poder realizar las operaciones CRUD `<Customer, Long>`. `Long` es el tipo de la clave primaria de la entidad `Customer`

A continuación se escribe la signatura de los métodos que van a acceder a los datos y debe devolver una entidad POJO o una lista de entidades POJO. No hace falta escribir el cuerpo de las consultas SQL ya que lo hace Spring Boot automáticamente por nosotros a partir del nombre del método y los parámetros.

Por ejemplo, `findById` nos devolverá aquel con Id igual al pasado como parámetro. `findAll` nos devolverá todos. Si creamos el método `findByName(string name)` devolvería aquellos con dicho `name` y `findByNameAndLastName` que coincida el `Name` y el `LastName`. Aquí se han definido un método:

* `findByLastName` devuelve una lista de `Customers` con dicho `LastName`

Tienes el listado completo de Querys [aquí](https://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/#jpa.query-methods.query-creation).

## Prueba de la aplicación

Ahora ya podemos crear un método para probar el funcionamiento de la aplicación

```java
package org.ieselcaminas.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import java.util.Optional;

@SpringBootApplication
public class JpaApplication implements CommandLineRunner{
	@Autowired
	private CustomerRepository repository;

	public static void main(String[] args) {
		SpringApplication.run(JpaApplication.class, args);
	}

	/**
	 * Este método se ejecuta automáticamente cuado el programa se lanza por consola porque
	 * implementa CommandLineRunner
	 * @param args
	 */
	@Override
	public void run(String... args) {
		// save a few customers
		repository.save(new Customer("Pepe", "Viyuela"));
		repository.save(new Customer("Juan", "Imedio"));
		repository.save(new Customer("María", "Imedio"));
		repository.save(new Customer("David", "Palmer"));

		// fetch all customers
		System.out.println("Customers found with findAll():");
		System.out.println("-------------------------------");
		for (Customer customer : repository.findAll()) {
			System.out.println(customer);
		}
		System.out.println("");

		// fetch an individual customer by ID
		Customer customer = repository.findById(1L);
		System.out.println("Customer found with findById(1L):");
		System.out.println("--------------------------------");
		System.out.println(customer);
		customer.setFirstName("Pedro");
		System.out.println("Customer modified");
		System.out.println(customer);
		System.out.println("");

		// fetch customers by last name
		System.out.println("Customer found with findByLastName('Imedio'):");
		System.out.println("--------------------------------------------");
		repository.findByLastName("Imedio").forEach(imedio -> {
			System.out.println(imedio);
		});

		System.out.println("");

	}
}
```

Vemos como el repositorio está anotado con `@Autowired`

```java
@Autowired
private CustomerRepository repository;
```

Esto significa que Spring automáticamente pasa como parámetro una instancia del repositorio. Este tipo de funcionamiento se denomina [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection)

Después se crean varios `Customers`

```java
repository.save(new Customer("Pepe", "Viyuela"));
```

> -info-Como veis no se crea ninguna base de datos ni tablas. Eso es porque estamos usando la base de datos H2 que se emplea en desarrollo y Spring Boot crea automáticamente una tabla por cada una de las clases que están anotadas con `@Entity`

